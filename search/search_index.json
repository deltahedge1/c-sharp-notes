{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C# notes Start a new project open up visual studio create a newproject and then name it Printing to console Console.WriteLine( \"hello world\" ); // To read a key input string input = Console.ReadLine(); Lists List< int > myList = new List< int >; var myOtherList = new List< int >; myList.Add( 1 ); List< int > myList2 = new List< int > { 1 , 2 , 5 }; foreach ( int i in myList2) { Console.WriteLine(i); } Arrays dataType[] nameOfArray = new dataType[arraySize]; int [] myArray = new int [ 10 ]; // 10 is the size of the array myArray[ 0 ] = 3 ; int [] myOtherArray = { 1 , 2 , 10 , 7 , 6 } Array.Sort(myOtherArray) // does it in place no need to assign Dictionary Instantiating Dictionary< string , int > Students = new Dictionary< string , int >(); Adding Students.Add( \"Ish\" , 1 ); Contains if (Students.Contains( \"Ish\" )) { Console.WriteLine( $\"students dict contains Ish and value is {Students[\" Ish \"]}\" ) } Remove Students.Remove(keyToRemove); Examples using System ; using System.Collections.Generic ; class Program { static void Main () { Dictionary< int , string > students = new Dictionary< int , string >(); students.Add( 1 , \"John\" ); students.Add( 2 , \"Emily\" ); students.Add( 3 , \"Michael\" ); // Remove a specific key-value pair from the dictionary int keyToRemove = 2 ; if (students.ContainsKey(keyToRemove)) { students.Remove(keyToRemove); Console.WriteLine( $\"Key {keyToRemove} removed from the dictionary.\" ); } else { Console.WriteLine( $\"Key {keyToRemove} does not exist in the dictionary.\" ); } // Iterate over the dictionary to verify the removal foreach (KeyValuePair< int , string > student in students) { Console.WriteLine( $\"ID: {student.Key}, Name: {student.Value}\" ); } } } Dictionary< string , int > scores = new Dictionary<String, int >(); scores.Add( \"Ish\" , 90 ); scores.Add( \"Jane\" , 95 ); scores.Add( \"Bob\" , 85 ); foreach ( var pair in scores) { Console.WriteLine( \"{0} {1}\" , pair.Key, pair.Value); } Dictionary< string , int > scores = new Dictionary< string , int >(); scores.Add( \"John\" , 90 ); scores.Add( \"Jane\" , 95 ); scores.Add( \"Bob\" , 80 ); foreach (KeyValuePair< string , int > pair in scores) { Console.WriteLine( \"{0}: {1}\" , pair.Key, pair.Value); } For loop for ( int i = 0 , i <= 5 , i++) { Console.WriteLine( int ); } While loop Not guaranteed to run atleast once like do while int i = 0 ; while (i <= 5 ) { Console.Writeline(i); i += 1 ; } Do while loop guaranteed to run the first loop int i = 0 ; do { Console.WriteLine(i); } while ( i < 5 ); Reference vs Value Types static void addOne ( ref int num) { Console.WriteLine( $\"value inside addOne {num}\" ); } static void Main ( string [] args) { int num = 0 ; addOne( ref num); Console.WriteLine( $\"original value: {num}\" ); } Null coalescing var a = variable ?? defaultVariable Person person = null ; Person newPerson = person ?? new Person( \"Default\" , \"Person\" ); Console.WriteLine(Person.FirstName); Constants vs readonly Constants Readonly Implicit static Not implicit static Constant must be initialised Does not need to be initialised Cannot hold custom types Can hold custom types class Program { public const string someText = \"This is text\" ; public static readonly string someOtherText = \"Other text\" ; static void Main ( string [] args) { Console.WriteLine(someText); } }","title":"Home"},{"location":"#c-notes","text":"","title":"C# notes"},{"location":"#start-a-new-project","text":"open up visual studio create a newproject and then name it","title":"Start a new project"},{"location":"#printing-to-console","text":"Console.WriteLine( \"hello world\" ); // To read a key input string input = Console.ReadLine();","title":"Printing to console"},{"location":"#lists","text":"List< int > myList = new List< int >; var myOtherList = new List< int >; myList.Add( 1 ); List< int > myList2 = new List< int > { 1 , 2 , 5 }; foreach ( int i in myList2) { Console.WriteLine(i); }","title":"Lists"},{"location":"#arrays","text":"dataType[] nameOfArray = new dataType[arraySize]; int [] myArray = new int [ 10 ]; // 10 is the size of the array myArray[ 0 ] = 3 ; int [] myOtherArray = { 1 , 2 , 10 , 7 , 6 } Array.Sort(myOtherArray) // does it in place no need to assign","title":"Arrays"},{"location":"#dictionary","text":"","title":"Dictionary"},{"location":"#instantiating","text":"Dictionary< string , int > Students = new Dictionary< string , int >();","title":"Instantiating"},{"location":"#adding","text":"Students.Add( \"Ish\" , 1 );","title":"Adding"},{"location":"#contains","text":"if (Students.Contains( \"Ish\" )) { Console.WriteLine( $\"students dict contains Ish and value is {Students[\" Ish \"]}\" ) }","title":"Contains"},{"location":"#remove","text":"Students.Remove(keyToRemove);","title":"Remove"},{"location":"#examples","text":"using System ; using System.Collections.Generic ; class Program { static void Main () { Dictionary< int , string > students = new Dictionary< int , string >(); students.Add( 1 , \"John\" ); students.Add( 2 , \"Emily\" ); students.Add( 3 , \"Michael\" ); // Remove a specific key-value pair from the dictionary int keyToRemove = 2 ; if (students.ContainsKey(keyToRemove)) { students.Remove(keyToRemove); Console.WriteLine( $\"Key {keyToRemove} removed from the dictionary.\" ); } else { Console.WriteLine( $\"Key {keyToRemove} does not exist in the dictionary.\" ); } // Iterate over the dictionary to verify the removal foreach (KeyValuePair< int , string > student in students) { Console.WriteLine( $\"ID: {student.Key}, Name: {student.Value}\" ); } } } Dictionary< string , int > scores = new Dictionary<String, int >(); scores.Add( \"Ish\" , 90 ); scores.Add( \"Jane\" , 95 ); scores.Add( \"Bob\" , 85 ); foreach ( var pair in scores) { Console.WriteLine( \"{0} {1}\" , pair.Key, pair.Value); } Dictionary< string , int > scores = new Dictionary< string , int >(); scores.Add( \"John\" , 90 ); scores.Add( \"Jane\" , 95 ); scores.Add( \"Bob\" , 80 ); foreach (KeyValuePair< string , int > pair in scores) { Console.WriteLine( \"{0}: {1}\" , pair.Key, pair.Value); }","title":"Examples"},{"location":"#for-loop","text":"for ( int i = 0 , i <= 5 , i++) { Console.WriteLine( int ); }","title":"For loop"},{"location":"#while-loop","text":"Not guaranteed to run atleast once like do while int i = 0 ; while (i <= 5 ) { Console.Writeline(i); i += 1 ; }","title":"While loop"},{"location":"#do-while-loop","text":"guaranteed to run the first loop int i = 0 ; do { Console.WriteLine(i); } while ( i < 5 );","title":"Do while loop"},{"location":"#reference-vs-value-types","text":"static void addOne ( ref int num) { Console.WriteLine( $\"value inside addOne {num}\" ); } static void Main ( string [] args) { int num = 0 ; addOne( ref num); Console.WriteLine( $\"original value: {num}\" ); }","title":"Reference vs Value Types"},{"location":"#null-coalescing","text":"var a = variable ?? defaultVariable Person person = null ; Person newPerson = person ?? new Person( \"Default\" , \"Person\" ); Console.WriteLine(Person.FirstName);","title":"Null coalescing"},{"location":"#constants-vs-readonly","text":"Constants Readonly Implicit static Not implicit static Constant must be initialised Does not need to be initialised Cannot hold custom types Can hold custom types class Program { public const string someText = \"This is text\" ; public static readonly string someOtherText = \"Other text\" ; static void Main ( string [] args) { Console.WriteLine(someText); } }","title":"Constants vs readonly"},{"location":"access-modifiers/","text":"Access Modifiers How Modifers Work Access Modifier Visibility public The type or member can be accessed from anywhere. private The type or member can only be accessed from within the same class. internal The type or member can only be accessed from within the same assembly. protected The type or member can only be accessed from within the same class or a derived class. protected internal The type or member can only be accessed from within the same assembly or a derived class in another assembly. private protected The type or member can only be accessed from within the same assembly and from any derived class in the same assembly. Example Code // This is a public class that can be accessed from anywhere. public class PublicClass { // This is a public field that can be accessed from anywhere. public int PublicField; // This is a public method that can be accessed from anywhere. public void PublicMethod () { // Implementation code goes here. } // This is a private method that can only be accessed from within this class. private void PrivateMethod () { // Implementation code goes here. } // This is an internal method that can only be accessed from within this assembly. internal void InternalMethod () { // Implementation code goes here. } // This is a protected method that can only be accessed from within this class or a derived class. protected void ProtectedMethod () { // Implementation code goes here. } // This is a protected internal method that can be accessed from within this assembly or a derived class in another assembly. protected internal void ProtectedInternalMethod () { // Implementation code goes here. } // This is a private protected method that can only be accessed from within this assembly and from any derived class in the same assembly. private protected void PrivateProtectedMethod () { // Implementation code goes here. } } // This is a class that derives from PublicClass and can access its protected and protected internal members. public class DerivedClass : PublicClass { public void AccessProtectedMembers () { ProtectedMethod(); ProtectedInternalMethod(); } } // This is a class in a different assembly that can only access PublicClass's public and protected internal members. public class ExternalClass { public void AccessPublicMembers (PublicClass obj) { obj.PublicField = 42 ; obj.PublicMethod(); obj.ProtectedInternalMethod(); // This is allowed because it's protected internal. // obj.PrivateMethod(); // This is not allowed because it's private. // obj.InternalMethod(); // This is not allowed because it's internal. // obj.PrivateProtectedMethod(); // This is not allowed because it's private protected. } }","title":"Access Modifiers"},{"location":"access-modifiers/#access-modifiers","text":"","title":"Access Modifiers"},{"location":"access-modifiers/#how-modifers-work","text":"Access Modifier Visibility public The type or member can be accessed from anywhere. private The type or member can only be accessed from within the same class. internal The type or member can only be accessed from within the same assembly. protected The type or member can only be accessed from within the same class or a derived class. protected internal The type or member can only be accessed from within the same assembly or a derived class in another assembly. private protected The type or member can only be accessed from within the same assembly and from any derived class in the same assembly.","title":"How Modifers Work"},{"location":"access-modifiers/#example-code","text":"// This is a public class that can be accessed from anywhere. public class PublicClass { // This is a public field that can be accessed from anywhere. public int PublicField; // This is a public method that can be accessed from anywhere. public void PublicMethod () { // Implementation code goes here. } // This is a private method that can only be accessed from within this class. private void PrivateMethod () { // Implementation code goes here. } // This is an internal method that can only be accessed from within this assembly. internal void InternalMethod () { // Implementation code goes here. } // This is a protected method that can only be accessed from within this class or a derived class. protected void ProtectedMethod () { // Implementation code goes here. } // This is a protected internal method that can be accessed from within this assembly or a derived class in another assembly. protected internal void ProtectedInternalMethod () { // Implementation code goes here. } // This is a private protected method that can only be accessed from within this assembly and from any derived class in the same assembly. private protected void PrivateProtectedMethod () { // Implementation code goes here. } } // This is a class that derives from PublicClass and can access its protected and protected internal members. public class DerivedClass : PublicClass { public void AccessProtectedMembers () { ProtectedMethod(); ProtectedInternalMethod(); } } // This is a class in a different assembly that can only access PublicClass's public and protected internal members. public class ExternalClass { public void AccessPublicMembers (PublicClass obj) { obj.PublicField = 42 ; obj.PublicMethod(); obj.ProtectedInternalMethod(); // This is allowed because it's protected internal. // obj.PrivateMethod(); // This is not allowed because it's private. // obj.InternalMethod(); // This is not allowed because it's internal. // obj.PrivateProtectedMethod(); // This is not allowed because it's private protected. } }","title":"Example Code"},{"location":"dot-net/","text":".Net CLI tutorial Making an example project dotnet new console -o ConsoleNameApp cd ConsoleNameApp dotnet new gitignore //add a gitignore dotnet new class -o ClassName //add a class file List .Net SDKs dotnet --list-sdks Creating a new console app dotnet new console -h //help dotnet new console -n myProj2 -f net6.0 dotnet new console --framework net6.0 --use-program-main Adding a CS gitignore dotnet new gitignore Run the app dotnet run Where are packages listed dotnet list packages Installing packages Project installation dotnet add package <package_name> --version <version> dotnet add package Humanizer --version 2.7.9 dotnet add package Humanizer --prerelease Global installation dotnet add --global <reference> List packages Project packages dotnet list package dotnet list package --outdated dotnet list package --outdated --include-prerelease Global tools dotnet tool list --global Add a reference dotnet add reference path/to/MyLibrary.dll Creating a nuget package dotnet build dotnet pack --configuration Release // will package it to bin/Release/packagename.version.nupkg dotnet nuget push <bin/Release/packagename.version.nupkg> --source https://api.nuget.org/v3/index.json --api-key <api_key>","title":".Net CLI"},{"location":"dot-net/#net-cli","text":"tutorial","title":".Net CLI"},{"location":"dot-net/#making-an-example-project","text":"dotnet new console -o ConsoleNameApp cd ConsoleNameApp dotnet new gitignore //add a gitignore dotnet new class -o ClassName //add a class file","title":"Making an example project"},{"location":"dot-net/#list-net-sdks","text":"dotnet --list-sdks","title":"List .Net SDKs"},{"location":"dot-net/#creating-a-new-console-app","text":"dotnet new console -h //help dotnet new console -n myProj2 -f net6.0 dotnet new console --framework net6.0 --use-program-main","title":"Creating a new console app"},{"location":"dot-net/#adding-a-cs-gitignore","text":"dotnet new gitignore","title":"Adding a CS gitignore"},{"location":"dot-net/#run-the-app","text":"dotnet run","title":"Run the app"},{"location":"dot-net/#where-are-packages-listed","text":"dotnet list packages","title":"Where are packages listed"},{"location":"dot-net/#installing-packages","text":"","title":"Installing packages"},{"location":"dot-net/#project-installation","text":"dotnet add package <package_name> --version <version> dotnet add package Humanizer --version 2.7.9 dotnet add package Humanizer --prerelease","title":"Project installation"},{"location":"dot-net/#global-installation","text":"dotnet add --global <reference>","title":"Global installation"},{"location":"dot-net/#list-packages","text":"","title":"List packages"},{"location":"dot-net/#project-packages","text":"dotnet list package dotnet list package --outdated dotnet list package --outdated --include-prerelease","title":"Project packages"},{"location":"dot-net/#global-tools","text":"dotnet tool list --global","title":"Global tools"},{"location":"dot-net/#add-a-reference","text":"dotnet add reference path/to/MyLibrary.dll","title":"Add a reference"},{"location":"dot-net/#creating-a-nuget-package","text":"dotnet build dotnet pack --configuration Release // will package it to bin/Release/packagename.version.nupkg dotnet nuget push <bin/Release/packagename.version.nupkg> --source https://api.nuget.org/v3/index.json --api-key <api_key>","title":"Creating a nuget package"},{"location":"files/","text":"Files in C Write Files string [] lines = { \"first line\" , \"second line\" , \"third line\" }; File.WriteAllLines( \"myFirstFile.txt\" , lines);","title":"Files"},{"location":"files/#files-in-c","text":"","title":"Files in C"},{"location":"files/#write-files","text":"string [] lines = { \"first line\" , \"second line\" , \"third line\" }; File.WriteAllLines( \"myFirstFile.txt\" , lines);","title":"Write Files"},{"location":"implementing-a-class/","text":"Implementing a Class Pro Tips 1. ToString In the ToString method you can get the class name using this.GetType().Name public override string ToString () { return $\"{this.GetType().Name()} {this.X} {this.Y}\" } 2. Equals In the Equals method good to implement two things check if the other object is null or not the same object type check if the properties are the same public override bool Equals ( object obj) { if (obj == null || obj != GetType()) return false ; return ( this .X == obj.X) && ( this .Y == obj.Y); } Code public class Person { public string Name { get ; set ;}; public int Age{ get ; set ;}; public Person ( string name, int age) { this .Name = name; this .Age = age; } public override string ToString () { return $\"class: {this.GetType().Name} name: {this.name} age: {this.name}\" } public override bool Equal ( object Obj) { if (obj == null || this .GetType() != obj.GetType()) { return false ; } Person p = (Person) obj; return ( this .Name == p.Name) && ( this .Age == p.Age); } public override int GetHashCode () { return (Name, Age).GetHasCode(); } }","title":"Implementing a Class"},{"location":"implementing-a-class/#implementing-a-class","text":"","title":"Implementing a Class"},{"location":"implementing-a-class/#pro-tips","text":"","title":"Pro Tips"},{"location":"implementing-a-class/#1-tostring","text":"In the ToString method you can get the class name using this.GetType().Name public override string ToString () { return $\"{this.GetType().Name()} {this.X} {this.Y}\" }","title":"1. ToString"},{"location":"implementing-a-class/#2-equals","text":"In the Equals method good to implement two things check if the other object is null or not the same object type check if the properties are the same public override bool Equals ( object obj) { if (obj == null || obj != GetType()) return false ; return ( this .X == obj.X) && ( this .Y == obj.Y); }","title":"2. Equals"},{"location":"implementing-a-class/#code","text":"public class Person { public string Name { get ; set ;}; public int Age{ get ; set ;}; public Person ( string name, int age) { this .Name = name; this .Age = age; } public override string ToString () { return $\"class: {this.GetType().Name} name: {this.name} age: {this.name}\" } public override bool Equal ( object Obj) { if (obj == null || this .GetType() != obj.GetType()) { return false ; } Person p = (Person) obj; return ( this .Name == p.Name) && ( this .Age == p.Age); } public override int GetHashCode () { return (Name, Age).GetHasCode(); } }","title":"Code"},{"location":"interface/","text":"Interface Interfaces in C# are used to define a set of methods, properties, and events that a class can implement. The following steps show how to use interfaces in C#: Define an Interface Define an interface: To define an interface in C#, use the interface keyword followed by the interface name and a set of members. For example: public interface IMyInterface { void DoSomething (); int CalculateSomething ( int x, int y); } This interface declares two members: DoSomething , which has no parameters and returns no value, and CalculateSomething , which takes two int parameters and returns an int result. Implement an Interface Implement the interface: To implement an interface in a class, use the : <interface> syntax after the class declaration. For example: public class MyClass : IMyInterface { public void DoSomething () { // implementation code goes here } public int CalculateSomething ( int x, int y) { // implementation code goes here return x + y; } } This class implements the IMyInterface interface by providing implementations for both of its members. Use the interface Use the interface: Once you have defined an interface and implemented it in a class, you can use the interface to interact with instances of that class. For example: IMyInterface myObject = new MyClass(); myObject.DoSomething(); int result = myObject.CalculateSomething( 3 , 4 ); Console.WriteLine(result); This code creates an instance of the MyClass class, which implements the IMyInterface interface. It then uses the IMyInterface variable myObject to call the DoSomething and CalculateSomething methods on the instance. By using interfaces in your code, you can write more flexible and reusable code that can work with a variety of different classes that implement the same interface.","title":"Interface"},{"location":"interface/#interface","text":"Interfaces in C# are used to define a set of methods, properties, and events that a class can implement. The following steps show how to use interfaces in C#:","title":"Interface"},{"location":"interface/#define-an-interface","text":"Define an interface: To define an interface in C#, use the interface keyword followed by the interface name and a set of members. For example: public interface IMyInterface { void DoSomething (); int CalculateSomething ( int x, int y); } This interface declares two members: DoSomething , which has no parameters and returns no value, and CalculateSomething , which takes two int parameters and returns an int result.","title":"Define an Interface"},{"location":"interface/#implement-an-interface","text":"Implement the interface: To implement an interface in a class, use the : <interface> syntax after the class declaration. For example: public class MyClass : IMyInterface { public void DoSomething () { // implementation code goes here } public int CalculateSomething ( int x, int y) { // implementation code goes here return x + y; } } This class implements the IMyInterface interface by providing implementations for both of its members.","title":"Implement an Interface"},{"location":"interface/#use-the-interface","text":"Use the interface: Once you have defined an interface and implemented it in a class, you can use the interface to interact with instances of that class. For example: IMyInterface myObject = new MyClass(); myObject.DoSomething(); int result = myObject.CalculateSomething( 3 , 4 ); Console.WriteLine(result); This code creates an instance of the MyClass class, which implements the IMyInterface interface. It then uses the IMyInterface variable myObject to call the DoSomething and CalculateSomething methods on the instance. By using interfaces in your code, you can write more flexible and reusable code that can work with a variety of different classes that implement the same interface.","title":"Use the interface"},{"location":"making-nuget-pkg/","text":"Making a nuget package step 1. Make and build a class file dotnet new class NugetPackageName dotnet new gitignore step 2. Modify the .csproj file <Project Sdk=\"Microsoft.NET.Sdk\" > <PropertyGroup> <TargetFramework> net7.0 </TargetFramework> <ImplicitUsings> enable </ImplicitUsings> <Nullable> enable </Nullable> <PackageId> {this should be unique} </PackageId> <Version> 1.0.4 </Version> <Authors> Ish Hassan </Authors> <Company> deltahedge1 </Company> <Product> AppLogger </Product> <Description> This is a test package that has a logger </Description> <PackageReadmeFile> README.md </PackageReadmeFile> <PackageLicenseFile> LICENSE </PackageLicenseFile> <PackageTags> Tag1 Tag_2 </PackageTags> <PackageReleaseNotes> Release notes for version 1.0.0: - Added new feature A. - Fixed issue B. - Improved performance. </PackageReleaseNotes> </PropertyGroup> <ItemGroup> <!-- Include README file in the package --> <None Include=\"README.md\" Pack=\"true\" PackagePath=\"\" CopyToOutputDirectory=\"Always\" /> <None Include=\"LICENSE.txt\" Pack=\"true\" PackagePath=\"\" CopyToOutputDirectory=\"Always\" /> </ItemGroup> </Project> step 3. Build and pack the package dotnet build dotnet pack --configuration Release // will package it to bin/Release/packagename.version.nupkg step 4. Release the package dotnet nuget push <bin/Release/packagename.version.nupkg> --source https://api.nuget.org/v3/index.json --api-key <api_key> Useful Links Microsoft Link Best Practices","title":"Making a nuget package"},{"location":"making-nuget-pkg/#making-a-nuget-package","text":"step 1. Make and build a class file dotnet new class NugetPackageName dotnet new gitignore step 2. Modify the .csproj file <Project Sdk=\"Microsoft.NET.Sdk\" > <PropertyGroup> <TargetFramework> net7.0 </TargetFramework> <ImplicitUsings> enable </ImplicitUsings> <Nullable> enable </Nullable> <PackageId> {this should be unique} </PackageId> <Version> 1.0.4 </Version> <Authors> Ish Hassan </Authors> <Company> deltahedge1 </Company> <Product> AppLogger </Product> <Description> This is a test package that has a logger </Description> <PackageReadmeFile> README.md </PackageReadmeFile> <PackageLicenseFile> LICENSE </PackageLicenseFile> <PackageTags> Tag1 Tag_2 </PackageTags> <PackageReleaseNotes> Release notes for version 1.0.0: - Added new feature A. - Fixed issue B. - Improved performance. </PackageReleaseNotes> </PropertyGroup> <ItemGroup> <!-- Include README file in the package --> <None Include=\"README.md\" Pack=\"true\" PackagePath=\"\" CopyToOutputDirectory=\"Always\" /> <None Include=\"LICENSE.txt\" Pack=\"true\" PackagePath=\"\" CopyToOutputDirectory=\"Always\" /> </ItemGroup> </Project> step 3. Build and pack the package dotnet build dotnet pack --configuration Release // will package it to bin/Release/packagename.version.nupkg step 4. Release the package dotnet nuget push <bin/Release/packagename.version.nupkg> --source https://api.nuget.org/v3/index.json --api-key <api_key>","title":"Making a nuget package"},{"location":"making-nuget-pkg/#useful-links","text":"Microsoft Link Best Practices","title":"Useful Links"},{"location":"naming-conventions/","text":"Naming Conventions What naming convention to use Naming Convention Example Case Classes Person , CustomerService , CarFactory PascalCase Interfaces IComparable , IDisposable , IEnumerable IPascalCase Local variables firstName , lastName , orderTotal camelCase Private fields _firstName or fastName starts with _ camelCase or without _ Constants MAX_RETRY_ATTEMPTS , ERROR_CODE_FILE_NOT_FOUND UPPERCASE_WITH_UNDERSCORES Properties Name , Address , IsEnabled PascalCase (noun or noun phrase) Methods Save , Delete , CalculateTotalCost PascalCase (verb or verb phrase) Code // Interface name should start with I public interface IExampleInterface { void DoSomething (); } // Constant name should be all uppercase with underscores separating words public static class ExampleConstants { public const int MAX_COUNT = 100 ; } // Class name should be in PascalCase public class ExampleClass { // Private field name should start with an underscore and be in camelCase private string _exampleField; // Property name should be in PascalCase public string ExampleProperty { get ; set ; } // Method name should be in PascalCase public void ExampleMethod () { // Local variable name should be in camelCase int exampleVariable = 0 ; // Constant should be referenced using all uppercase with underscores separating words Console.WriteLine( $\"The maximum count is {ExampleConstants.MAX_COUNT}\" ); } }","title":"Naming Convention"},{"location":"naming-conventions/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"naming-conventions/#what-naming-convention-to-use","text":"Naming Convention Example Case Classes Person , CustomerService , CarFactory PascalCase Interfaces IComparable , IDisposable , IEnumerable IPascalCase Local variables firstName , lastName , orderTotal camelCase Private fields _firstName or fastName starts with _ camelCase or without _ Constants MAX_RETRY_ATTEMPTS , ERROR_CODE_FILE_NOT_FOUND UPPERCASE_WITH_UNDERSCORES Properties Name , Address , IsEnabled PascalCase (noun or noun phrase) Methods Save , Delete , CalculateTotalCost PascalCase (verb or verb phrase)","title":"What naming convention to use"},{"location":"naming-conventions/#code","text":"// Interface name should start with I public interface IExampleInterface { void DoSomething (); } // Constant name should be all uppercase with underscores separating words public static class ExampleConstants { public const int MAX_COUNT = 100 ; } // Class name should be in PascalCase public class ExampleClass { // Private field name should start with an underscore and be in camelCase private string _exampleField; // Property name should be in PascalCase public string ExampleProperty { get ; set ; } // Method name should be in PascalCase public void ExampleMethod () { // Local variable name should be in camelCase int exampleVariable = 0 ; // Constant should be referenced using all uppercase with underscores separating words Console.WriteLine( $\"The maximum count is {ExampleConstants.MAX_COUNT}\" ); } }","title":"Code"},{"location":"useful-links/","text":"Useful links .Net fundamentals documentation C# tutorials MS learn","title":"Useful Links"},{"location":"useful-links/#useful-links","text":".Net fundamentals documentation C# tutorials MS learn","title":"Useful links"}]}