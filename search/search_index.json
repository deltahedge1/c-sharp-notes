{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C# notes Start a new project open up visual studio create a newproject and then name it Printing to console Console.WriteLine(\"hello world\"); // To read a key input string input = Console.ReadLine(); Lists List<int> myList = new List<int>; var myOtherList = new List<int>; myList.Add(1); List<int> myList2 = new List<int> {1, 2, 5}; foreach (int i in myList2) { Console.WriteLine(i); } Arrays int[] myArray = new int[10]; // 10 is the size of the array myArray[0] = 3; int[] myOtherArray = {1, 2, 10, 7, 6} Array.Sort(myOtherArray) // does it in place no need to assign Dictionary Dictionary<string, int> scores = new Dictionary<String, int>(); scores.Add(\"Ish\", 90); scores.Add(\"Jane\", 95); scores.Add(\"Bob\", 85); foreach (var pair in scores) { Console.WriteLine(\"{0} {1}\", pair.Key, pair.Value); } Dictionary<string, int> scores = new Dictionary<string, int>(); scores.Add(\"John\", 90); scores.Add(\"Jane\", 95); scores.Add(\"Bob\", 80); foreach (KeyValuePair<string, int> pair in scores) { Console.WriteLine(\"{0}: {1}\", pair.Key, pair.Value); } For loop for(int i = 0, i <= 5, i++) { Console.WriteLine(int); } While loop Not guaranteed to run atleast once like do while int i = 0; while(i <= 5) { Console.Writeline(i); i += 1; } Do while loop guaranteed to run the first loop int i = 0; do { Console.WriteLine(i); } while ( i < 5); Reference vs Value Types static void addOne(ref int num) { Console.WriteLine($\"value inside addOne {num}\"); } static void Main(string[] args) { int num = 0; addOne(ref num); Console.WriteLine($\"original value: {num}\"); } Null coalescing var a = variable ?? defaultVariable Person person = null; Person newPerson = person ?? new Person(\"Default\", \"Person\"); Console.WriteLine(Person.FirstName); Constants vs readonly Constants Readonly Implicit static Not implicit static Constant must be initialised Does not need to be initialised Cannot hold custom types Can hold custom types class Program { public const string someText = \"This is text\"; public static readonly string someOtherText = \"Other text\"; static void Main(string[] args) { Console.WriteLine(someText); } }","title":"Home"},{"location":"#c-notes","text":"","title":"C# notes"},{"location":"#start-a-new-project","text":"open up visual studio create a newproject and then name it","title":"Start a new project"},{"location":"#printing-to-console","text":"Console.WriteLine(\"hello world\"); // To read a key input string input = Console.ReadLine();","title":"Printing to console"},{"location":"#lists","text":"List<int> myList = new List<int>; var myOtherList = new List<int>; myList.Add(1); List<int> myList2 = new List<int> {1, 2, 5}; foreach (int i in myList2) { Console.WriteLine(i); }","title":"Lists"},{"location":"#arrays","text":"int[] myArray = new int[10]; // 10 is the size of the array myArray[0] = 3; int[] myOtherArray = {1, 2, 10, 7, 6} Array.Sort(myOtherArray) // does it in place no need to assign","title":"Arrays"},{"location":"#dictionary","text":"Dictionary<string, int> scores = new Dictionary<String, int>(); scores.Add(\"Ish\", 90); scores.Add(\"Jane\", 95); scores.Add(\"Bob\", 85); foreach (var pair in scores) { Console.WriteLine(\"{0} {1}\", pair.Key, pair.Value); } Dictionary<string, int> scores = new Dictionary<string, int>(); scores.Add(\"John\", 90); scores.Add(\"Jane\", 95); scores.Add(\"Bob\", 80); foreach (KeyValuePair<string, int> pair in scores) { Console.WriteLine(\"{0}: {1}\", pair.Key, pair.Value); }","title":"Dictionary"},{"location":"#for-loop","text":"for(int i = 0, i <= 5, i++) { Console.WriteLine(int); }","title":"For loop"},{"location":"#while-loop","text":"Not guaranteed to run atleast once like do while int i = 0; while(i <= 5) { Console.Writeline(i); i += 1; }","title":"While loop"},{"location":"#do-while-loop","text":"guaranteed to run the first loop int i = 0; do { Console.WriteLine(i); } while ( i < 5);","title":"Do while loop"},{"location":"#reference-vs-value-types","text":"static void addOne(ref int num) { Console.WriteLine($\"value inside addOne {num}\"); } static void Main(string[] args) { int num = 0; addOne(ref num); Console.WriteLine($\"original value: {num}\"); }","title":"Reference vs Value Types"},{"location":"#null-coalescing","text":"var a = variable ?? defaultVariable Person person = null; Person newPerson = person ?? new Person(\"Default\", \"Person\"); Console.WriteLine(Person.FirstName);","title":"Null coalescing"},{"location":"#constants-vs-readonly","text":"Constants Readonly Implicit static Not implicit static Constant must be initialised Does not need to be initialised Cannot hold custom types Can hold custom types class Program { public const string someText = \"This is text\"; public static readonly string someOtherText = \"Other text\"; static void Main(string[] args) { Console.WriteLine(someText); } }","title":"Constants vs readonly"},{"location":"access-modifiers/","text":"Access Modifiers How Modifers Work Access Modifier Visibility public The type or member can be accessed from anywhere. private The type or member can only be accessed from within the same class. internal The type or member can only be accessed from within the same assembly. protected The type or member can only be accessed from within the same class or a derived class. protected internal The type or member can only be accessed from within the same assembly or a derived class in another assembly. private protected The type or member can only be accessed from within the same assembly and from any derived class in the same assembly. Example Code // This is a public class that can be accessed from anywhere. public class PublicClass { // This is a public field that can be accessed from anywhere. public int PublicField; // This is a public method that can be accessed from anywhere. public void PublicMethod() { // Implementation code goes here. } // This is a private method that can only be accessed from within this class. private void PrivateMethod() { // Implementation code goes here. } // This is an internal method that can only be accessed from within this assembly. internal void InternalMethod() { // Implementation code goes here. } // This is a protected method that can only be accessed from within this class or a derived class. protected void ProtectedMethod() { // Implementation code goes here. } // This is a protected internal method that can be accessed from within this assembly or a derived class in another assembly. protected internal void ProtectedInternalMethod() { // Implementation code goes here. } // This is a private protected method that can only be accessed from within this assembly and from any derived class in the same assembly. private protected void PrivateProtectedMethod() { // Implementation code goes here. } } // This is a class that derives from PublicClass and can access its protected and protected internal members. public class DerivedClass : PublicClass { public void AccessProtectedMembers() { ProtectedMethod(); ProtectedInternalMethod(); } } // This is a class in a different assembly that can only access PublicClass's public and protected internal members. public class ExternalClass { public void AccessPublicMembers(PublicClass obj) { obj.PublicField = 42; obj.PublicMethod(); obj.ProtectedInternalMethod(); // This is allowed because it's protected internal. // obj.PrivateMethod(); // This is not allowed because it's private. // obj.InternalMethod(); // This is not allowed because it's internal. // obj.PrivateProtectedMethod(); // This is not allowed because it's private protected. } }","title":"Access-Modifiers"},{"location":"access-modifiers/#access-modifiers","text":"","title":"Access Modifiers"},{"location":"access-modifiers/#how-modifers-work","text":"Access Modifier Visibility public The type or member can be accessed from anywhere. private The type or member can only be accessed from within the same class. internal The type or member can only be accessed from within the same assembly. protected The type or member can only be accessed from within the same class or a derived class. protected internal The type or member can only be accessed from within the same assembly or a derived class in another assembly. private protected The type or member can only be accessed from within the same assembly and from any derived class in the same assembly.","title":"How Modifers Work"},{"location":"access-modifiers/#example-code","text":"// This is a public class that can be accessed from anywhere. public class PublicClass { // This is a public field that can be accessed from anywhere. public int PublicField; // This is a public method that can be accessed from anywhere. public void PublicMethod() { // Implementation code goes here. } // This is a private method that can only be accessed from within this class. private void PrivateMethod() { // Implementation code goes here. } // This is an internal method that can only be accessed from within this assembly. internal void InternalMethod() { // Implementation code goes here. } // This is a protected method that can only be accessed from within this class or a derived class. protected void ProtectedMethod() { // Implementation code goes here. } // This is a protected internal method that can be accessed from within this assembly or a derived class in another assembly. protected internal void ProtectedInternalMethod() { // Implementation code goes here. } // This is a private protected method that can only be accessed from within this assembly and from any derived class in the same assembly. private protected void PrivateProtectedMethod() { // Implementation code goes here. } } // This is a class that derives from PublicClass and can access its protected and protected internal members. public class DerivedClass : PublicClass { public void AccessProtectedMembers() { ProtectedMethod(); ProtectedInternalMethod(); } } // This is a class in a different assembly that can only access PublicClass's public and protected internal members. public class ExternalClass { public void AccessPublicMembers(PublicClass obj) { obj.PublicField = 42; obj.PublicMethod(); obj.ProtectedInternalMethod(); // This is allowed because it's protected internal. // obj.PrivateMethod(); // This is not allowed because it's private. // obj.InternalMethod(); // This is not allowed because it's internal. // obj.PrivateProtectedMethod(); // This is not allowed because it's private protected. } }","title":"Example Code"},{"location":"dot-net/","text":".Net CLI tutorial List .Net SDKs dotnet --list-sdks Creating a new console app dotnet new console -h #help dotnet new console -n myProj2 -f net6.0 Run the app dotnet run Where are packages listed dotnet list packages Installing packages dotnet add package <package_name> --version <version> dotnet add package Humanizer --version 2.7.9 dotnet add package Humanizer --prerelease List packages dotnet list package dotnet list package --outdated dotnet list package --outdated --include-prerelease","title":".Net CLI"},{"location":"dot-net/#net-cli","text":"tutorial","title":".Net CLI"},{"location":"dot-net/#list-net-sdks","text":"dotnet --list-sdks","title":"List .Net SDKs"},{"location":"dot-net/#creating-a-new-console-app","text":"dotnet new console -h #help dotnet new console -n myProj2 -f net6.0","title":"Creating a new console app"},{"location":"dot-net/#run-the-app","text":"dotnet run","title":"Run the app"},{"location":"dot-net/#where-are-packages-listed","text":"dotnet list packages","title":"Where are packages listed"},{"location":"dot-net/#installing-packages","text":"dotnet add package <package_name> --version <version> dotnet add package Humanizer --version 2.7.9 dotnet add package Humanizer --prerelease","title":"Installing packages"},{"location":"dot-net/#list-packages","text":"dotnet list package dotnet list package --outdated dotnet list package --outdated --include-prerelease","title":"List packages"},{"location":"files/","text":"Files in C Write Files string[] lines = {\"first line\", \"second line\", \"third line\"}; File.WriteAllLines(\"myFirstFile.txt\", lines);","title":"Files"},{"location":"files/#files-in-c","text":"","title":"Files in C"},{"location":"files/#write-files","text":"string[] lines = {\"first line\", \"second line\", \"third line\"}; File.WriteAllLines(\"myFirstFile.txt\", lines);","title":"Write Files"},{"location":"interface/","text":"Interface Interfaces in C# are used to define a set of methods, properties, and events that a class can implement. The following steps show how to use interfaces in C#: Define an Interface Define an interface: To define an interface in C#, use the interface keyword followed by the interface name and a set of members. For example: public interface IMyInterface { void DoSomething(); int CalculateSomething(int x, int y); } This interface declares two members: DoSomething , which has no parameters and returns no value, and CalculateSomething , which takes two int parameters and returns an int result. Implement an Interface Implement the interface: To implement an interface in a class, use the : <interface> syntax after the class declaration. For example: public class MyClass : IMyInterface { public void DoSomething() { // implementation code goes here } public int CalculateSomething(int x, int y) { // implementation code goes here return x + y; } } This class implements the IMyInterface interface by providing implementations for both of its members. Use the interface Use the interface: Once you have defined an interface and implemented it in a class, you can use the interface to interact with instances of that class. For example: IMyInterface myObject = new MyClass(); myObject.DoSomething(); int result = myObject.CalculateSomething(3, 4); Console.WriteLine(result); This code creates an instance of the MyClass class, which implements the IMyInterface interface. It then uses the IMyInterface variable myObject to call the DoSomething and CalculateSomething methods on the instance. By using interfaces in your code, you can write more flexible and reusable code that can work with a variety of different classes that implement the same interface.","title":"Interface"},{"location":"interface/#interface","text":"Interfaces in C# are used to define a set of methods, properties, and events that a class can implement. The following steps show how to use interfaces in C#:","title":"Interface"},{"location":"interface/#define-an-interface","text":"Define an interface: To define an interface in C#, use the interface keyword followed by the interface name and a set of members. For example: public interface IMyInterface { void DoSomething(); int CalculateSomething(int x, int y); } This interface declares two members: DoSomething , which has no parameters and returns no value, and CalculateSomething , which takes two int parameters and returns an int result.","title":"Define an Interface"},{"location":"interface/#implement-an-interface","text":"Implement the interface: To implement an interface in a class, use the : <interface> syntax after the class declaration. For example: public class MyClass : IMyInterface { public void DoSomething() { // implementation code goes here } public int CalculateSomething(int x, int y) { // implementation code goes here return x + y; } } This class implements the IMyInterface interface by providing implementations for both of its members.","title":"Implement an Interface"},{"location":"interface/#use-the-interface","text":"Use the interface: Once you have defined an interface and implemented it in a class, you can use the interface to interact with instances of that class. For example: IMyInterface myObject = new MyClass(); myObject.DoSomething(); int result = myObject.CalculateSomething(3, 4); Console.WriteLine(result); This code creates an instance of the MyClass class, which implements the IMyInterface interface. It then uses the IMyInterface variable myObject to call the DoSomething and CalculateSomething methods on the instance. By using interfaces in your code, you can write more flexible and reusable code that can work with a variety of different classes that implement the same interface.","title":"Use the interface"}]}